1. 是否听说过Spring的循环依赖？
https://zhuanlan.zhihu.com/p/382066829

一级缓存 singletonObjects： 就是存的 最终的成品
二级缓存 earlySingletonObjects： 就是为存 半成品Bean
三级缓存 singletonFactories： 就是为存 bean工厂



2. 选择消息中间件MQ时，如何进行选型的考虑？例如：容错性等。

https://juejin.cn/post/6850418106372882446
消息队列面试连环问：如何保证消息不丢失？处理重复消息？消息有序性？消息堆积处理

https://juejin.cn/post/6844903951834284045
为什么要使用MQ消息中间件?这3个点让你彻底明白！

https://stor.51cto.com/art/202101/640335.htm
Redis消息队列的三种方案（List，Streams， Pub/Sub）

我们使用的消息队列，一般都有什么样的特点：
（1）三个角色：生产者、消费者、消息处理中心
（2）异步处理模式：
    生产者 将消息发送到一条虚拟的通道(消息队列)上，而无须等待响应。
    消费者则 订阅 或是 监听 该通道，取出消息。
    两者互不干扰，甚至都不需要同时在线，也就是我们说的 松耦合。
（3）可靠性：消息要可以保证不丢失、不重复消费、有时可能还需要顺序性的保证


3. Mybatis的#和$，哪个可以防止注入攻击？为什么？

https://www.zhihu.com/question/26914370/answer/150328023

Mybatis本身是基于JDBC封装的。
#{parameter} 是预编译处理（PreparedStatement）范畴的。
${parameter} 只是字符串替换。
Mybatis在处理#时，会调用PreparedStatement的 set系列方法 来赋值；
但是处理$时，只是把${parameter}替换成变量的值。

因此，使用#{parameter}，可以有效的防止SQL注入攻击，提高系统安全性。

进一步说明PreparedStatement:
PreparedStatement是Statement的孩子，不同的是，PreparedStatement使用预编译机制，
在创建PreparedStatement对象时就需要将SQL语句传入，传入的过程中参数要用？替代，
这个过程会导致传入的SQL被进行预编译，然后再调用PreparedStatement的SetXXX将参数
设置上去，由于SQL语句已经经过了预编译，再传入特殊值也已经不起作用（失效）了！

画外音：
只有数据被当成SQL去经历解析、编译，才有可能被数据库认识并执行（注入攻击），
无意义的字符数据库是不会管的。


4. 在分布式（多JVM）情况下，如何用到分布式锁来解决多进程间的并发问题？例如：使用Redis锁？

https://blog.csdn.net/l_bestcoder/article/details/79336986

分布式锁的关键，是在分布式的应用服务器外，搭建一个存储服务器，存储锁信息。
例如搭建一个Redis服务器，用来存储锁信息。

在实现的时候，要注意的几个关键点：
1.锁信息必须是会超时过期的，不能让一个线程长期占有一个锁而导致死锁。
2.同一时刻，只能有一个线程获取到锁。

几个要用到的Redis命令：
setnx(key, value):      'set if not exists'，若该key-value不存在，则成功加入缓存，并且返回1，否则返回0.
get(key):               获得key对应的value值，若不存在则返回nil.
getset(key, value):     先获取key对应的value值，若不存在则返回nil，然后将旧的value更新为新的value.
expire(key, seconds):   设置key-value的有效期为seconds秒。


https://www.jianshu.com/p/12a8c57d2295
高并发场景下的解决方案以及分布式锁的实现(包括：MySQL的悲观锁、乐观锁，Redis分布式锁)

https://blog.csdn.net/zxd1435513775/article/details/122194202
Redis实现分布式锁
包括几种改进方式
高并发场景下，多个Tomcat服务器在Redis里，使用setnx命令设置锁，成功的话再去执行定时任务。
执行定时任务完成后，主动删除锁del key，释放锁。

改进1:
设置锁之后，立即加上锁的过期时间，使用expire命令，以防Tomcat服务器突然down机，避免一直死锁。
// 为key加一个过期时间
Boolean flag = template.opsForValue().setIfAbsent(REDIS_LOCK, value,10L,TimeUnit.SECONDS);

改进2:
设置锁的时候，必须把自己的UUID加到锁的value里，这样子可以防止锁过期之后，被其他Tomcat服务器加锁，
而自己运行超时之后，又把其他Tomcat服务器加的锁给删除了。只有自己可以删除自己的锁！

改进3:
自己判断是否自己的锁时候，再删除自己的锁。这个不属于“原子操作”，并发的时候会出现问题！
所以最好的办法，使用Lua脚本来完成 锁的判断 和 锁的删除 这两个操作！


5. 请问有没有项目使用了Redis等缓存架构？
https://www.jianshu.com/p/e9132e42ba4c
使用Redis，你必须知道的21个注意要点

Redis 6.0 版本之前：（单线程）
读取网络请求和解析 + 数据的读写 = 一个线程完成
Redis 6.0 版本之后：（多线程）
读取网络请求和解析 = 多个线程完成
数据的读写 = 一个主线程完成

Redis两种持久化机制之一：AOF机制原理
要点1：AOF是写后日志，这样带来的好处是，记录的所有操作命令都是正确的，不需要额外的语法检查，确保redis重启时能够正确的读取回复数据
要点2：AOF日志写入磁盘是比较影响性能的，为了平衡性能与数据安全，开发了三种机制：
①：立即写入Always ②：按秒写入Everysec ③：系统写入No
要点3：AOF日志会变得巨大，所以Redis提供了日志重整的机制，通过读取内存中的数据重新产生一份数据写入日志
后台子进程：berewriteaof

Redis两种持久化方式之二：RDB方式
要点1：RDB快照，将此时内存中的所有的数据写入磁盘
要点2：生成快照有两种方式：sava 和 bgsava
save 是主进程执行，生成时会阻塞redis，只能执行查找。
bgsave 是由主进程fork出子进程执行，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长
要点3：子进程在被fork处理时，与主进程共享同一份内存，但在生成快照时采取COW (Copy on Write)机制，确保不会阻塞主进程的数据读写
要点4：RDB的执行频率很重要，这会影响到数据的完整性和Redis的性能稳定性。所以4.0后有了aof和rdb混合的数据持久化机制



6. 你了解乐观锁和悲观锁吗？ 
https://www.cnblogs.com/kismetv/p/10787228.html
一、基本概念
二、实现方式(含实例)
      1、CAS（Compare And Swap）
      2、版本号机制
三、优缺点和适用场景
四、面试官追问：乐观锁加锁吗？
五、面试官追问：CAS有哪些缺点？
六、总结
